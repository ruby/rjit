#!/usr/bin/env ruby
# frozen_string_literal: true
#
# Build ../ruby first and then execute this file.
#
# Usage:
#   $ bin/bindgen                # Assumes ../ruby does in-place build
#   $ bin/bindgen RUBY_BUILD_DIR # Assumes RUBY_BUILD_DIR builds ../ruby

require 'rubygems/source'
require 'bundler/inline'
gemfile(true) do
  source 'https://rubygems.org'
  gem 'ffi-clang', '0.7.0', require: false
  gem 'fiddle', '1.1.6', require: false
end

# Help ffi-clang find libclang
# Hint: apt install libclang1
ENV['LIBCLANG'] ||= Dir.glob("/usr/lib/llvm-*/lib/libclang.so.1").grep_v(/-cpp/).sort.last
require 'ffi/clang'

require 'etc'
require 'fiddle/import'
require 'set'

class Node < Struct.new(
  :kind,
  :spelling,
  :type,
  :typedef_type,
  :bitwidth,
  :sizeof_type,
  :offsetof,
  :enum_value,
  :children,
  keyword_init: true,
)
end

# Parse a C header with ffi-clang and return Node objects.
# To ease the maintenance, ffi-clang should be used only inside this class.
class HeaderParser
  def initialize(header, cflags:)
    @translation_unit = FFI::Clang::Index.new.parse_translation_unit(header, cflags, [], {})
  end

  def parse
    parse_children(@translation_unit.cursor)
  end

  private

  def parse_children(cursor)
    children = []
    cursor.visit_children do |cursor, _parent|
      children << parse_cursor(cursor)
      next :continue
    end
    children
  end

  def parse_cursor(cursor)
    unless cursor.kind.start_with?('cursor_')
      raise "unexpected cursor kind: #{cursor.kind}"
    end
    kind = cursor.kind.to_s.delete_prefix('cursor_').to_sym
    children = parse_children(cursor)

    offsetof = {}
    if kind == :struct
      children.select { |c| c.kind == :field_decl }.each do |child|
        offsetof[child.spelling] = cursor.type.offsetof(child.spelling)
      end
    end

    sizeof_type = nil
    if %i[struct union].include?(kind)
      sizeof_type = cursor.type.sizeof
    end

    enum_value = nil
    if kind == :enum_constant_decl
      enum_value = cursor.enum_value
    end

    Node.new(
      kind: kind,
      spelling: cursor.spelling,
      type: cursor.type.spelling,
      typedef_type: cursor.typedef_type.spelling,
      bitwidth: cursor.bitwidth,
      sizeof_type: sizeof_type,
      offsetof: offsetof,
      enum_value: enum_value,
      children: children,
    )
  end
end

require_relative "binding_generator"

ruby_dir = File.expand_path('../ruby', __dir__)
ruby_build_dir = ARGV.first&.then { |it| File.expand_path(it) } || ruby_dir

rjit_dir = File.expand_path('..', __dir__)
rjit_c_rb = File.join(rjit_dir, 'lib/rjit/c.rb')
rjit_c_h = File.join(rjit_dir, 'src/rjit/c.h')
cflags = [
  ruby_dir,
  ruby_build_dir,
  File.join(ruby_dir, 'include'),
  File.join(ruby_build_dir, ".ext/include/#{RUBY_PLATFORM}"),
].map { |dir| "-I#{dir}" }

# Clear .cache/clangd created by the language server, which could break this bindgen
clangd_cache = File.join(ruby_dir, '.cache/clangd')
if Dir.exist?(clangd_cache)
  system('rm', '-rf', clangd_cache, exception: true)
end

# Parse rjit_c.h and generate rjit_c.rb
nodes = HeaderParser.new(rjit_c_h, cflags: cflags).parse
generator = BindingGenerator.generator(rjit_c_rb)
generator.generate(nodes)

# Write rjit_c.rb
File.write(rjit_c_rb, generator.src)
